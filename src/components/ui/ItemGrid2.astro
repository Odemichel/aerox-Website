---
import { Icon } from 'astro-icon/components';
import { twMerge } from 'tailwind-merge';
import type { ItemGrid as Props } from '~/types';
import type { ImageMetadata } from 'astro';

import Button from './Button.astro';

const { items = [], defaultIcon = '', classes = {} } = Astro.props;

const {
  container: containerClass = '',
  panel: panelClass = '',
  title: titleClass = '',
  description: descriptionClass = '',
  objectif: objectifClass = '',
  icon: defaultIconClass = 'text-primary',
} = classes;

const srcFrom = (img?: { src?: string | ImageMetadata }) =>
  typeof img?.src === 'string' ? img.src : (img?.src?.src ?? '');

// Scroll infini : on duplique 3×
// const looped = [...items, ...items, ...items];
const list = items;

// id unique pour le carrousel
const carouselId = `carousel-${Math.random().toString(36).slice(2, 8)}`;
---

{
  items && items.length > 0 && (
    <div
      id={carouselId}
      class={twMerge(
        // Carrousel horizontal (toutes tailles) + UX scrollbar
        'flex overflow-x-auto scrollbar-custom snap-x snap-mandatory gap-4 px-6 -mx-6 scroll-px-6',
        containerClass
      )}
      aria-label="Carrousel infini d’items"
    >
      {list.map(({ title, description, objectif, icon, image, video, callToAction, classes: itemClasses = {} }, i) => (
        <article
          class={twMerge(
            // élément scrollable (teasing : on voit la carte suivante)

            'snap-center shrink-0 min-w-[85%] md:min-w-[420px] xl:min-w-[520px] max-w-[55%]',
            // carte
            'bg-white/5 rounded-2xl p-0 sm:p-0',
            'relative flex flex-col gap-2 ',
            'border-2 dark:hover:border-primary-light ',
            panelClass,
            itemClasses?.panel
          )}
          tabindex="0"
          role="group"
          data-idx={i}
          data-playing="false"
        >
          {/* ICONE + TITRE */}
          <div class="flex items-start gap-4">
            {(icon || defaultIcon) && (
              <Icon
                name={icon || defaultIcon}
                class={twMerge('mt-4 ml-4 w-6 h-6', defaultIconClass, itemClasses?.icon)}
              />
            )}
            {/* Bloc texte en colonne */}
            <div class="flex-1 min-w-0 mt-4">
              {title && (
                <h3 class={twMerge('text-lg md:text-2xl font-semibold', titleClass, itemClasses?.title)}>{title}</h3>
              )}

              {objectif && (
                <p class={twMerge('mt-1 text-muted', objectifClass, itemClasses?.description)} set:html={objectif} />
              )}
            </div>
          </div>

        {/* MEDIA (image OU vidéo) */}
{(image || video) && (
  <>
    <div class="relative overflow-visible w-full aspect-video border rounded-xl dark:border-secondary">
      {video ? (
        <>
          <video
            src={video?.src ?? ''}
            poster={video?.poster ?? ''}
            loop
            playsinline
            preload="metadata"
            class="media-el w-full h-full rounded-2xl object-contain bg-black"
            data-video
          />

          {/* Play centré */}
          <button
            type="button"
            class="absolute inset-0 grid place-items-center transition
              data-[hidden=true]:opacity-0 data-[hidden=true]:pointer-events-none"
            aria-label="Lire la vidéo"
            data-play
          >
            <span class="rounded-full p-3 md:p-4 bg-primary border-2 border-primary-light text-white shadow-lg">
              <Icon name="tabler:player-play-filled" class="w-6 h-6 md:w-8 md:h-8" />
            </span>
          </button>
        </>
      ) : (
        <div class="relative overflow-visible h-full video-ratio border dark:rounded-xl dark:border-secondary">
          <img
            src={srcFrom(image)}
            alt={image?.alt ?? ''}
            loading="lazy"
            class="w-full h-full video-ratio object-contain bg-black rounded-xl dark:border-secondary"
          />
        </div>
      )}

      {/* Si tu gardes un dégradé interne au média */}
      <div class="video-gradient hidden sm:block pointer-events-none absolute inset-x-0 bottom-0 h-1/2" />
    </div>

    {/* DESCRIPTION SOUS le média (plus d'absolute) */}
    {(description || callToAction) && (
      <div class="mt-3 p-2 sm:p-3 rounded-lg shadow-md
                  bg-white/90 text-black dark:bg-black dark:text-white
                  max-w-full">
        {description && (
          <p
            class={twMerge(
              'text-sm lg:text-base leading-snug',
              descriptionClass,
              itemClasses?.description
            )}
            set:html={description}
          />
        )}

        {callToAction && (
          <div class="mt-2 flex flex-wrap justify-end gap-2">
            {Array.isArray(callToAction) ? (
              callToAction.map((cta) => (
                <Button
                  {...cta}
                  class={twMerge(
                    'px-3 py-1.5 text-sm rounded-md',
                    'bg-black/5 hover:bg-black/10 dark:bg-white/10 dark:hover:bg-white/20',
                    'text-current',
                    cta.class ?? ''
                  )}
                />
              ))
            ) : (
              <Button
                {...callToAction}
                class={twMerge(
                  'px-3 py-1.5 text-sm rounded-md',
                  'bg-black/5 hover:bg-black/10 dark:bg-white/10 dark:hover:bg-white/20',
                  'text-current',
                  callToAction.class ?? ''
                )}
              />
            )}
          </div>
        )}
      </div>
    )}
  </>
)}

        </article>
      ))}
    </div>
  )
}

<style is:inline>
  /* Masquer proprement la scrollbar (optionnel) */
  article[data-playing='false'] .media-el {
    filter: blur(3px) brightness(0.85);
    transition:
      filter 500ms ease,
      transform 500ms ease;
    transform: scale(0.98); /* léger zoom pour gommer les bords du blur */
  }

  /* Quand ça joue : on rétablit net */
  article[data-playing='true'] .media-el {
    filter: none;
    transition:
      filter 500ms ease,
      transform 500ms ease;
  }

  /* Masquer la description/CTA pendant la lecture */
  article[data-playing='true'] .desc-overlay {
    opacity: 0;
    pointer-events: none;
    transition:
      opacity 500ms ease,
      filter 500ms ease;
  }

  /* Visible par défaut quand ça ne joue pas */
  article[data-playing='false'] .desc-overlay {
    opacity: 1;
    pointer-events: auto;
    transition:
      opacity 500ms ease,
      filter 500ms ease;
  }
  .scrollbar-none::-webkit-scrollbar {
    display: none;
  }
  .scrollbar-none {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  @media (prefers-reduced-motion: reduce) {
    article .media-el {
      filter: none !important;
      transform: none !important;
      transition: none !important;
    }
    article .desc-overlay {
      transition: none !important;
    }
  }
</style>
<script define:vars={{ carouselId }}>
  const el = document.getElementById(carouselId);
  if (!el) {
    console.warn('Carousel introuvable:', carouselId);
  }

  if (el) {
    // ⚠️ SUPPRIMÉ : recalc / setSpan (causait ReferenceError)
    // window.addEventListener('resize', recalc);

    // -- Handlers Play/Pause --
    el.querySelectorAll('[data-play]').forEach((btn) => {
      const wrap = btn.closest('article');
      if (!wrap) return;
      const video = wrap.querySelector('video[data-video]');
      if (!video) return;

      const syncState = () => {
        const playing = !video.paused && !video.ended;
        wrap.dataset.playing = playing ? 'true' : 'false';
        btn.dataset.hidden = playing ? 'true' : 'false';
      };

      // init
      syncState();

      // toggle via overlay
      btn.addEventListener('click', () => {
        if (video.paused || video.ended) video.play();
        else video.pause();
      });

      // toggle via clic vidéo
      video.addEventListener('click', () => {
        if (video.paused || video.ended) video.play();
        else video.pause();
      });

      ['play', 'pause', 'ended', 'waiting', 'seeking'].forEach((evt) =>
        video.addEventListener(evt, syncState)
      );
    });

    // --- Lazy-load + pause hors écran (simple, sans sets dupliqués) ---
    const makeIO = () => {
      if (!('IntersectionObserver' in window)) return;

      const io = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            const card = entry.target;
            const video = card.querySelector('video[data-video]');
            const playBtn = card.querySelector('[data-play]');
            if (!video) return;

            if (entry.isIntersecting) {
              if (video.dataset.src && !video.src) video.src = video.dataset.src;
              playBtn?.removeAttribute('disabled');
            } else {
              if (!video.paused && !video.ended) video.pause();
            }
          });
        },
        { root: el, threshold: 0.6 }
      );

      // Observe toutes les cartes (plus de /3)
      Array.from(el.children).forEach((c) => io.observe(c));
    };

    makeIO();
  }
</script>

