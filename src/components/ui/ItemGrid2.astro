---
import { Icon } from 'astro-icon/components';
import { twMerge } from 'tailwind-merge';
import type { ItemGrid as Props } from '~/types';
import Button from './Button.astro';

const { items = [], defaultIcon = '', classes = {} } = Astro.props;

const {
  container: containerClass = '',
  panel: panelClass = '',
  title: titleClass = '',
  description: descriptionClass = '',
  objectif: objectifClass = '',
  icon: defaultIconClass = 'text-primary',
} = classes;

// Scroll infini : on duplique 3×
const looped = [...items, ...items, ...items];

// id unique pour le carrousel
const carouselId = `carousel-${Math.random().toString(36).slice(2, 8)}`;
---

{
  items && items.length > 0 && (
    <div
      id={carouselId}
      class={twMerge(
        // Carrousel horizontal (toutes tailles) + UX scrollbar
        'flex overflow-x-auto snap-x snap-mandatory gap-4 px-6 -mx-6 scroll-px-6',
        'scrollbar-none [scrollbar-width:none] [-ms-overflow-style:none]',
        containerClass
      )}
      aria-label="Carrousel infini d’items"
      
  
    >
      {looped.map(
        ({ title, description, objectif, icon, image, video, callToAction, classes: itemClasses = {} }, i) => (
          <article
            class={twMerge(
              // élément scrollable (teasing : on voit la carte suivante)

              'snap-center shrink-0 min-w-[85%] md:min-w-[420px] xl:min-w-[520px] max-w-[55%]',
              // carte
              'bg-white/5 rounded-2xl p-0 sm:p-0',
              'relative flex flex-col gap-2 ',
              'border-2 dark:hover:border-primary-light ',
              panelClass,
              itemClasses?.panel
            )}
            tabindex="0"
            role="group"
            data-idx={i}
            data-playing="false"
          >
            {/* ICONE + TITRE */}
            <div class="flex items-start gap-2">
              {(icon || defaultIcon) && (
                <Icon
                  name={icon || defaultIcon}
                  class={twMerge('mt-4 ml-4 w-6 h-6', defaultIconClass, itemClasses?.icon)}
                />
              )}
              {/* Bloc texte en colonne */}
              <div class="flex-1 min-w-0 mt-4">
                {title && (
                  <h3 class={twMerge('text-lg md:text-2xl font-semibold', titleClass, itemClasses?.title)}>{title}</h3>
                )}

                {objectif && (
                  <p class={twMerge('mt-1 text-muted', objectifClass, itemClasses?.description)} set:html={objectif} />
                )}
              </div>
            </div>

            {/* MEDIA (image OU vidéo) */}
            {(image || video) && (
              <div class="relative overflow-visible w-full aspect-video border rounded-xl dark:border-secondary">
                {video ? (
                  <>
                    <video
                      src={video?.src ?? ''}
                      poster={video?.poster ?? ''}
                      loop
                      playsinline
                      preload="metadata"
                      class="media-el w-full h-full rounded-2xl object-contain bg-black"
                      data-video
                    />

                    {/* Play centré */}
                    <button
                      type="button"
                      class="absolute inset-0 grid place-items-center transition
               data-[hidden=true]:opacity-0 data-[hidden=true]:pointer-events-none"
                      aria-label="Lire la vidéo"
                      data-play
                    >
                      <span class="rounded-full p-3 md:p-4 bg-primary border-2 border-primary-light text-white shadow-lg">
                        <Icon name="tabler:player-play-filled" class="w-6 h-6 md:w-8 md:h-8" />
                      </span>
                    </button>
                  </>
                ) : (
                  <img
                    src={image?.src ?? ''}
                    alt={image?.alt ?? ''}
                    loading="lazy"
                    class="w-full h-full object-contain bg-black"
                  />
                )}

                {/* Dégradé plus bas en mobile */}
<div class="video-gradient hidden sm:block pointer-events-none absolute inset-x-0 bottom-0 h-1/2 "></div>

                {/* Overlay description + CTA — collé en bas, compact en mobile */}
                <div class="desc-overlay absolute inset-x-0 bottom-[-8px] md:bottom-0 p-2 sm:p-4 text-white transition-opacity">
                  <div
                    class={twMerge(
                      'pointer-events-auto m-0 sm:m-2 p-2 sm:p-3 rounded-lg shadow-md',
                      'bg-white/90 text-black dark:bg-black/70 dark:text-white backdrop-blur',
                      'max-w-[100%] max-h-[38%] sm:max-h-none overflow-hidden', // <-- limite la hauteur en mobile
                      itemClasses?.description
                    )}
                  >
                    {description && (
                      <p
                        class={twMerge(
                          // si tu as le plugin line-clamp:
                          'text-sm lg:text-base leading-snug ',
                          descriptionClass,
                          itemClasses?.description
                        )}
                        set:html={description}
                      />
                    )}

                    {callToAction && (
                      <div class="mt-2 flex flex-wrap justify-end gap-2">
                        {Array.isArray(callToAction) ? (
                          callToAction.map((cta) => (
                            <Button
                              {...cta}
                              class={twMerge(
                                'px-3 py-1.5 text-sm rounded-md',
                                'bg-black/5 hover:bg-black/10 dark:bg-white/10 dark:hover:bg-white/20',
                                'text-current',
                                cta.class ?? ''
                              )}
                            />
                          ))
                        ) : (
                          <Button
                            {...callToAction}
                            class={twMerge(
                              'px-3 py-1.5 text-sm rounded-md',
                              'bg-black/5 hover:bg-black/10 dark:bg-white/10 dark:hover:bg-white/20',
                              'text-current',
                              callToAction.class ?? ''
                            )}
                          />
                        )}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
          </article>
        )
      )}
    </div>
  )
}

<style is:inline>
  /* Masquer proprement la scrollbar (optionnel) */
  article[data-playing='false'] .media-el {
    filter: blur(3px) brightness(0.85);
    transition:
      filter 500ms ease,
      transform 500ms ease;
    transform: scale(0.98); /* léger zoom pour gommer les bords du blur */
  }

  /* Quand ça joue : on rétablit net */
  article[data-playing='true'] .media-el {
    filter: none;
    transition:
      filter 500ms ease,
      transform 500ms ease;
  }

  /* Masquer la description/CTA pendant la lecture */
  article[data-playing='true'] .desc-overlay {
    opacity: 0;
    pointer-events: none;
    transition: opacity 500ms ease,
    filter 500ms ease;
  }

  /* Visible par défaut quand ça ne joue pas */
  article[data-playing='false'] .desc-overlay {
    opacity: 1;
    pointer-events: auto;
    transition: opacity 500ms ease,
    filter 500ms ease;
  }
  .scrollbar-none::-webkit-scrollbar {
    display: none;
  }
  .scrollbar-none {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  @media (prefers-reduced-motion: reduce) {
  article .media-el {
    filter: none !important;
    transform: none !important;
    transition: none !important;
  }
  article .desc-overlay {
    transition: none !important;
  }
}
</style>
<script define:vars={{ carouselId }}>
  // Récupère le conteneur du carrousel par ID injecté depuis le frontmatter
  const el = document.getElementById(carouselId);
  if (!el) {
    console.warn('Carousel introuvable:', carouselId);
  }

  if (el) {
    const cards = Array.from(el.children);
    const setSize = cards.length / 3; // taille d’un set original (items x3)
    const offset0 = cards[0].offsetLeft;
    let setSpan = cards[setSize].offsetLeft - cards[0].offsetLeft; // largeur d’un set complet
    const buffer = 2;

    // placer le scroll au set du milieu
    const firstMid = cards[setSize];
    const centerLeft = firstMid.offsetLeft - (el.clientWidth - firstMid.clientWidth) / 2;
    el.scrollLeft = centerLeft;
    const recalc = () => {
      setSpan = cards[setSize].offsetLeft - cards[0].offsetLeft;
    };
    window.addEventListener('resize', recalc);

    let ticking = false;
    el.addEventListener(
      'scroll',
      () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            const x = el.scrollLeft;
            if (x < offset0 + buffer)
              el.scrollLeft = x + setSpan; // bord gauche → saute +setSpan
            else if (x > offset0 + setSpan * 2 - buffer) el.scrollLeft = x - setSpan; // bord droit → saute -setSpan
            ticking = false;
          });
          ticking = true;
        }
      },
      { passive: true }
    );

    // Gestion du bouton Play overlay
    el.querySelectorAll('[data-play]').forEach((btn) => {
      const wrap = btn.closest('article');
      if (!wrap) return;
      const video = wrap.querySelector('video[data-video]');
      if (!video) return;

      const syncState = () => {
        const playing = !video.paused && !video.ended;
        wrap.dataset.playing = playing ? 'true' : 'false';
        // masquer le bouton Play quand ça joue (tu l’avais déjà)
        btn.dataset.hidden = playing ? 'true' : 'false';
      };

      // init
      syncState();

      // toggle via overlay
      btn.addEventListener('click', () => {
        if (video.paused || video.ended) video.play();
        else video.pause();
      });

      // toggle via clic vidéo
      video.addEventListener('click', () => {
        if (video.paused || video.ended) video.play();
        else video.pause();
      });

      // sync sur les événements clés
      ['play', 'pause', 'ended', 'waiting', 'seeking'].forEach((evt) => video.addEventListener(evt, syncState));
    });
  }
  // --- Lazy-load + pause hors écran (sans autoplay) ---
const makeIO = () => {
  if (!('IntersectionObserver' in window)) return;

  const cards = Array.from(el.children);
  const originalsCount = cards.length / 3; // set original
  const originals = cards.slice(0, originalsCount).concat(cards.slice(originalsCount, originalsCount*2)); // deux sets centraux

  const io = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      const card = entry.target;
      const video = card.querySelector('video[data-video]');
      const playBtn = card.querySelector('[data-play]');
      if (!video) return;

      if (entry.isIntersecting) {
        // Lazy set src (si tu veux différer le chargement)
        if (video.dataset.src && !video.src) {
          video.src = video.dataset.src;
        }
        // Rendre le bouton play actif seulement si visible
        playBtn?.removeAttribute('disabled');
      } else {
        // Pause si l'utilisateur a lancé la lecture et que la carte sort de l'écran
        if (!video.paused && !video.ended) video.pause();
      }
    });
  }, { root: el, threshold: 0.6 }); // 60% de la carte visible

  originals.forEach((c) => io.observe(c));
};

makeIO();
</script>
